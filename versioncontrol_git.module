<?php
// $Id: versioncontrol_git.module,v 1.21 2009/03/18 01:27:05 marvil07 Exp $
/**
 * @file
 * Git backend for Version Control API - Provides Git commit information and
 * account management as a pluggable backend.
 *
 * Copyright 2008 by Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

// Update methods.
define('VERSIONCONTROL_GIT_UPDATE_CRON', 0);
define('VERSIONCONTROL_GIT_UPDATE_XGIT', 1);

// The admin and user edit pages.
include_once(drupal_get_path('module', 'versioncontrol_git') .'/versioncontrol_git.admin.inc');

/**
 * Implementation of hook_help().
 */
function versioncontrol_git_help($section, $arg) {
  $output = '';
  if ($section == 'admin/help/versioncontrol_git' || $section == 'admin/help#versioncontrol_git') {
    $output = '<p>The Git Backend can be used to retrieve and view commit information. The commit
      information can either be retreived automatically through the use of the <i>xgit</i> scripts
      or using the <i>fetch now</i> link on the project administration repository page. The logs
      are then defaultly avaliable through the <i>commitlog</i> page.</p>
      <p>Information reguarding the setup of <i>xgit</i> scripts is aviable in the <i>README.txt</i>
      located in the <i>xgit</i> directory.</p>
      <p>If you have any questions, comments, or feature requests please visit the
      <a href="http://drupal.org/project/versioncontrol_git">module page</a> and
      post your concerns in the issue quene.</p>';
  }

  return $output;
}

/**
 * Implementation of hook_versioncontrol_backends().
 *
 * @return
 *   A structured array containing information about this known backends.
 *   Array key is the unique string identifier of the version control system.
 *   The corresponding array values are again structured arrays and consist
 *   of elements with the following keys:
 *
 *   'name': The user-visible name of the VCS.
 *   'description': A short description of the backend, if possible not longer
 *                  than one or two sentences.
 *   'capabilities': An array listing optional capabilities, in addition to the
 *                   required functionality like retrieval of detailed
 *                   commit information. Array values can be an arbitrary
 *                   combination of VERSIONCONTROL_CAPABILITY_* values. If no
 *                   additional capabilities are supported by the backend,
 *                   this array will be empty.
 *   'autoadd': An array listing which tables should be managed by
 *              Version Control API instead of doing it manually in
 *              the backend. Array values can be an arbitrary combination of
 *              VERSIONCONTROL_AUTOADD_* values. If no array additions
 *              should be automatically managed, this array will be empty.
 */
function versioncontrol_git_versioncontrol_backends() {
  return array(
    // The array key is up to 8 characters long, and used as unique identifier
    // for this VCS, in functions, URLs and in the database.
    'git' => array(
      // The user-visible name of the VCS.
      'name' => 'Git',

      // A short description of the VCS, if possible not longer than one or two sentences.
      'description' => t('Git (Fast Version Control System) is a version control system designed to handle very large projects with speed and efficiency; it is used mainly for various open source projects, most notably the Linux kernel.'),

      // A list of optional capabilities, in addition to the required retrieval
      // of detailed commit information.
      'capabilities' => array(
        // Use the commit hash for to identify the commit instead of an idvidual
        // revision for each file.
        VERSIONCONTROL_CAPABILITY_ATOMIC_COMMITS
      ),

      // An array listing which tables should be managed by Version Control API
      // instead of doing it manually in the backend.
      'flags' => array(
        // versioncontrol_insert_repository() will automatically insert
        // array elements from $repository['git_specific'] into
        // {versioncontrol_git_repositories} and versioncontrol_get_repositories()
        // will automatically fetch it from there.
        VERSIONCONTROL_FLAG_AUTOADD_REPOSITORIES,
      ),
    ),
  );
}

/**
 * Implementation of hook_menu().
 */
function versioncontrol_git_menu() {
  global $user;
  $items = array();

  $items['admin/project/versioncontrol-repositories/update/git'] = array(
    'title' => 'Fetch log',
    'page callback' => 'versioncontrol_git_update_repository_callback',
    'access callback' => 'user_access',
    'access arguments' => array('administer version control systems'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_cron():
 * Update repositories that have log fetching enabled.
 */
function versioncontrol_git_cron() {
  $result = db_query("SELECT repo_id FROM {versioncontrol_git_repositories}
                      WHERE update_method = %d", VERSIONCONTROL_GIT_UPDATE_CRON);

  // Set timeout limit to 3600 seconds as it can take a long time to process
  // the log initially. (And hook_cron() might be called by poormanscron.)
  if (!ini_get('safe_mode')) {
    set_time_limit(3600);
  }
  while ($repo = db_fetch_object($result)) {
    $repository = versioncontrol_get_repository($repo->repo_id);
    if (isset($repository)) {
      _versioncontrol_git_update_repository($repository);
    }
  }
}

/**
 * Implementation of [versioncontrol_backend]_format_revision_identifier():
 * Get the user-visible version of a commit identifier a.k.a. 'revision',
 * as plaintext.
 *
 * Version control backends can choose to implement their own version of this
 * function, which for example makes it possible to cut the SHA-1 hash in
 * distributed version control systems down to a readable length.
 *
 * @param $revision
 *   The commit identifier that should be themed.
 * @param $format
 *   Either 'full' for the original version, or 'short' for a more compact form.
 *   If the commit identifier doesn't need to be shortened, the results can
 *   be the same for both versions.
 */
function versioncontrol_git_format_revision_identifier($revision, $format = 'full') {
  switch ($format) {
    case 'full':
      return $revision;
    case 'short':
    default:
      // $revision == '30581e4ec3347d1294ec05a91eec1a8588e5993c'
      // Let's return only the first 12 characters of the revision identifier,
      // like Mercurial (including hgweb) does by default.
      return substr($revision, 0, 12);
  }
}

/**
 * Implementation of [versioncontrol_backend]_get_selected_label_from_operation():
 * Retrieve the tag or branch that applied to that item during the given
 * operation. The result of this function will be used for the selected label
 * property of the item, which is necessary to preserve the item state
 * throughout navigational API functions.
 *
 * This function is mandatory for backends to implement.
 *
 * @param $operation
 *   A single operation array to which the item belongs, like the ones returned
 *   by versioncontrol_get_operations(). Specifically, $operation contains the
 *   'labels' element which should probably be reused by this function.
 * @param $target_item
 *   The item revision for which the label should be retrieved.
 *
 * @return
 *   NULL if the given item does not belong to any label or if the appropriate
 *   label cannot be retrieved. Otherwise a label array is returned, consisting
 *   of the following elements:
 *
 *   - 'name': The branch or tag name (a string).
 *   - 'type': Whether this label is a branch (indicated by the
 *        VERSIONCONTROL_OPERATION_BRANCH constant) or a tag
 *        (VERSIONCONTROL_OPERATION_TAG).
 *
 *   In case the label array also contains the 'label_id' element (which
 *   happens when it's copied from the $operation['labels'] array) there will
 *   be a small performance improvement as the label doesn't need to be
 *   compared to and loaded from the database anymore.
 */
function versioncontrol_git_get_selected_label_from_operation($operation, $target_item) {
  // How CVS and many other version control systems will probably do it,
  // as they have exactly one label assigned to each operation.
  //TODO: implement versioncontrol_git_get_selected_label_from_operation
  return array();

  // If an operation - or more specifically, a commit - applies to multiple
  // branches and/or tags (as can happen in SVN, for example), then the correct
  // label for each item has to be determined.
}


/**
 * Implementation of [versioncontrol_backend]_get_selected_label_from_other_item():
 * Retrieve a valid label (tag or branch) for a new @p $target_item that is
 * (hopefully) similar or related to that of the given @p $other_item which
 * already has a selected label assigned. If the backend cannot find a related
 * label, return any valid label. The result of this function will be used for
 * the selected label property of each item, which is necessary to preserve the
 * item state throughout navigational API functions.
 *
 * This function is mandatory for backends to implement.
 *
 * @param $repository
 *   The repository array (like returned by versioncontrol_get_repository())
 *   of the repository which contains both the source and the successor item.
 * @param $target_item
 *   The item revision for which the label should be retrieved.
 * @param $other_item
 *   The item revision that the selected label should be derived from.
 *   For example, if @p $other_item in a CVS repository is at revision
 *   '1.5.2.1' which is on the 'DRUPAL-6--1' branch, and the @p $target_item
 *   is at revision '1.5' (its predecessor) which is present on both the
 *   'DRUPAL-6--1' and 'HEAD' branches, then this function should return a
 *   label array for the 'DRUPAL-6--1' branch.
 * @param $other_item_tags
 *   An array with a simple list of strings that describe properties of the
 *   @p $other_item, in relation to the @p $target_item. You can use those
 *   in order to make assumptions so that the selected label can be retrieved
 *   more accurately or with better performance. Version Control API passes a
 *   list that may contain zero or more of the following tags:
 *
 *   - 'source_item': The @p $other_item is a predecessor of the
 *        @p $target_item - same entity, but in an earlier revision and
 *        potentially with a different path, too (only if the backend supports
 *        item moves).
 *   - 'successor_item': The @p $other_item is a successor of the
 *        @p $target_item - same entity, but in a later revision and
 *        potentially with a different path, too (only if the backend supports
 *        item moves).
 *   - 'same_revision': The @p $other_item is at the same (global) revision
 *        as the @p $target_item. Specifically meant for backends whose
 *        version control systems don't support atomic commits.
 *
 * @return
 *   NULL if the given item does not belong to any label or if an appropriate
 *   label cannot be retrieved. Otherwise a label array is returned, consisting
 *   of the following elements:
 *
 *   - 'name': The branch or tag name (a string).
 *   - 'type': Whether this label is a branch (indicated by the
 *        VERSIONCONTROL_OPERATION_BRANCH constant) or a tag
 *        (VERSIONCONTROL_OPERATION_TAG).
 *
 *   In case the label array also contains the 'label_id' element (which
 *   happens when it's copied from the $operation['labels'] array) there will
 *   be a small performance improvement as the label doesn't need to be
 *   compared to and loaded from the database anymore.
 */
function versioncontrol_git_get_selected_label_from_other_item($repository, $target_item, &$other_item, $other_item_tags = array()) {
  // First up, optimizations - maybe we can do without the generic
  // "label transfer" code from further down and use assumptions instead.
  return NULL;
  //TODO: implement
  // Let's assume for FakeVCS repositories that if an item wears a label, then
  // an item at another path but with the same (file-level) revision can also
  // wear that same label. That is the case with some version control systems
  // (e.g. Git, Mercurial, Bazaar) but might not be the case with others
  // (CVS for its lack of global revision identifiers, SVN for its use of
  // directory structure as tag/branch identifiers).
  if ($item['revision'] == $other_item['revision']) {
    return versioncontrol_get_item_selected_label($repository, $other_item);
  }

  // If the $other_item is a successor item on a branch, some version control
  // systems (like CVS) can guarantee that the $target_item, the predecessor,
  // is always on the same branch. So no need for database queries, yay.
  if (in_array('successor_item', $other_item_tags)) {
    $label = versioncontrol_get_item_selected_label($repository, $other_item);

    if (isset($label['type']) && $label['type'] == VERSIONCONTROL_OPERATION_BRANCH) {
      return $label;
    }
  }

  // Otherwise we might not be able to derive the $target_item's label,
  // in which case we need to fall back to the database or a VCS invocation.
  // For example, something like this.
  if (versioncontrol_fetch_item_revision_id($repository, $target_item)) {
    $constraints = array(
      'item_revision_id' => array($target_item['item_revision_id']),
    );
    $commit_operations = versioncontrol_get_commit_operations($constraints);

    if (!empty($commit_operations)) { // yo, found the associated commit!
      // Code taken from the CVS backend, which only assigns a single branch
      // to any given commit operation, so it can just take the first one.
      $commit_operation = reset($commit_operations); // first (only) element
      return $commit_operation['labels'][0];
    }
  }

  // (You can even do more attempts if you want to, like trying to ask
  // the VCS itself. Or maybe not, depends on your motivation and the
  // VCS's capabilities.)

  // No label could be retrieved by looking at the other item, sorry.
  return NULL;
}

/**
 * Implementation of [versioncontrol_backend]_account_username_suggestion():
 * Return the most accurate guess on what the VCS username for a Drupal user
 * might look like in the given repository.
 *
 * @param $repository
 *   The repository where the the VCS account exists or will be located.
 * @param $user
 *  The Drupal user who wants to register an account.
 *  @TODO: adjust later
 */
function versioncontrol_git_account_username_suggestion($repository, $user) {
  // For distributed version control systems, the user's email address might be
  // a more appropriate username than the actual nick - it guarantees unique
  // identification (= uid association for operations), even though it might
  // need to be replaced by or amended with the full name on page display.
  return $user->mail;
}

/**
 * Implementation of [versioncontrol_backend]_is_account_username_valid():
 * Determine if the given repository allows a username to exist.
 *
 * This function is optional for backend modules to implement. If it's not
 * implemented, only usernames will be accepted that consist solely of
 * alphanumeric characters.
 *
 * @param $repository
 *   The repository where the the VCS account exists or will be located.
 * @param $username
 *  The username to check. It is passed by reference so if the username is
 *  valid but needs minor adaptions (such as cutting away unneeded parts) then
 *  it the backend can modify it before returning the result.
 *
 * @return
 *   TRUE if the username is valid, FALSE if not.
 *   @TODO: adjust, too
 */
function versioncontrol_git_is_account_username_valid($repository, &$username) {
  // Continuing the email-style username example from above.
  return valid_email_address($username);
}


/**
 * Implementation of [versioncontrol_backend]_alter_commits():
 * Add VCS specific repository data into a $commit['[xxx]_specific'] array,
 * and/or unset commits that don't match VCS specific filter constraints.
 * By convention, this function only adds data in this specific element
 * and doesn't modify other parts of the commit array.
 *
 * Version Control API doesn't filter commits by backend before passing them
 * to this function, so make sure you check each $commit['repository']['vcs']
 * property before messing with this specific commit.
 *
 * Also, this function is optional for backend modules to implement. If you
 * don't need custom commit additions or constraints, just don't implement it.
 *
 * @param $commits
 *   The unfiltered commits retrieved by versioncontrol_get_commits(), and
 *   even the '[xxx]_specific' arrays already exist. (If the
 *   VERSIONCONTROL_FLAG_AUTOADD_COMMITS flag has been set by this module,
 *   it may even be filled with values already.)
 * @param $fakevcs_specific_constraints
 *   An array of FakeVCS specific filter constraints which were passed to
 *   versioncontrol_get_commits(). Say, if FakeVCS supported modules like
 *   the CVS ones, the array would maybe contain a 'modules' constraint
 *   for filtering by module.
 */
/*
function versioncontrol_git_alter_commits(&$commits, $fakevcs_specific_constraints = array()) {
  foreach ($commits as $key => $commit) {
    // Disregard commits from other backends.
    if ($commit['repository']['vcs'] != 'git') {
      continue;
    }

    $additions = array();

    // Get branches.
    $result = db_query('SELECT branch_id FROM {versioncontrol_git_commit_branches} WHERE vc_op_id = %d', $commit['vc_op_id']);
    while ($branch = db_fetch_object($result)) {
      $additions['branch_ids'][] = $branch->branch_id;
    }

    // Merge the additions into the existing commit array.
    $commits[$key]['git_specific'] = array_merge($commit['git_specific'], $additions);
  }
}
*/
/**
 * Implementation of [versioncontrol_backend]_get_commit_actions():
 * Retrieve detailed information about what happened in a single commit.
 *
 * @param $commit
 *   The commit whose actions should be retrieved.
 *
 * @return
 *   A structured array containing the exact details of what happened to
 *   each item in this commit. Array keys are the current/new paths, also for
 *   VERSIONCONTROL_ACTION_DELETED actions even if the file actually doesn't
 *   exist anymore. The corresponding array values are again structured arrays
 *   and consist of elements with the following keys:
 *
 *   'action': Specifies how the item was modified.
 *             One of the predefined VERSIONCONTROL_ACTION_* values.
 *   'modified': Boolean value, specifies if a file was modified in addition
 *               to the other action in the 'action' element of the array.
 *               Only exists for the VERSIONCONTROL_ACTION_MOVED
 *               and VERSIONCONTROL_ACTION_COPIED actions.
 *   'current item': The updated state of the modified item. Exists for all
 *                   actions except VERSIONCONTROL_ACTION_DELETED.
 *   'source items': An array with the previous state(s) of the modified item.
 *                   Path and branch will always be the same as in the current
 *                   item except for the VERSIONCONTROL_ACTION_MOVED,
 *                   VERSIONCONTROL_ACTION_COPIED and
 *                   VERSIONCONTROL_ACTION_MERGED actions.
 *                   Exists for all actions except VERSIONCONTROL_ACTION_ADDED.
 *
 *   Item values are structured arrays and consist of elements
 *   with the following keys:
 *
 *   'type': Specifies the item type, which is either
 *           VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   'path': The path of the item at the specific revision.
 *   'revision': The (file-level) revision when the item was changed.
 *               If there is no such revision (which may be the case for
 *               directory items) then the 'revision' element is
 *               an empty string.
 *   '[xxx]_specific': May be set by the backend to remember additional
 *                     item info. ("[xxx]" is the unique string identifier
 *                     of the respective version control system.)
 */
/*
function versioncontrol_git_get_commit_actions($commit) {
  include_once(drupal_get_path('module', 'versioncontrol_git') .'/versioncontrol_git.log.inc');

  $actions = array();
  $result = db_query('SELECT item_revision_id, action, type, path,
                             lines_added, lines_removed
                      FROM {versioncontrol_git_item_revisions}
                      WHERE vc_op_id = %d', $commit['vc_op_id']);

  while ($item_revision = db_fetch_object($result)) {
    $action = array(
      'action' => $item_revision->action,
      'git_specific' => array(
        'lines_added' => $item_revision->lines_added,
        'lines_removed' => $item_revision->lines_removed,
      ),
    );

    if ($item_revision->action != VERSIONCONTROL_ACTION_DELETED) {
      $action['current item'] = array(
        'type' => $item_revision->type,
        'path' => $item_revision->path,
        'revision' => $commit['revision'],
        'git_specific' => array(
          'item_revision_id' => $item_revision->item_revision_id,
          'selected_branch_ids' => $commit['git_specific']['branch_ids'],
          'selected_op' => $commit,
        ),
      );
    }
    if ($item_revision->action != VERSIONCONTROL_ACTION_ADDED) {
      $source_items = versioncontrol_git_get_source_items($item_revision->item_revision_id);
      $action['source items'] = array(array(
        'type' => $item_revision->type,
        'path' => $item_revision->path,
        'revision' => count($source_items) > 0 ? versioncontrol_git_get_item_revision($source_items[0]) : '', // TODO Figure out what to do with multiple source items.
        'git_specific' => array(
          'item_revision_id' => $item_revision->item_revision_id,
          'selected_branch_ids' => $commit['git_specific']['branch_ids'],
          'selected_op' => $commit,
        ),
      ));
    }

    $actions[$item_revision->path] = $action;
  }
//  var_dump($actions);

  return $actions;
}*/

/**
 * Implementation of [versioncontrol_backend]_get_commit_statistics():
 * Retrieve general statistics about what happened in a single commit. For more granular
 * details about what happened in a single commit, use versioncontrol_get_commit_actions.
 *
 * @param $commit
 *   The commit to retrieve statistics about
 *
 * @return
 *  A structured array containing general statistics about this commit. The array will consist
 *  of elements with the following keys:
 *
 *   - 'lines_added': Total number of lines added during this commit
 *   - 'lines_removed': Total number of lines removed during this commit
 *   - 'action_count': Total number of actions within this commit
 *   - 'per_action_statistics': An array containing statistics on individual actions. Array keys are
 *        the current/new paths (just as with versioncontrol_get_commit_actions). The corresponding
 *        array values are again structured arrays and consist of elements with the following keys:
 *   
 *   - 'lines_added': Number of lines added in this action
 *   - 'lines_removed': Number of lines removed in this action
 */
/*
function versioncontrol_git_get_commit_statistics($commit, $commit_actions = NULL) {
  if ($commit_actions == NULL) {
    $commit_actions = versioncontrol_git_get_commit_actions($commit);
  }

  $total_lines_added = 0;
  $total_lines_removed = 0;
  $per_action = array();

  foreach ($commit_actions as $path => $action) {
    $per_action[$path] = array();

    $per_action[$path]['lines_added'] = $action['git_specific']['lines_added'];
    $total_lines_added += $per_action[$path]['lines_added'];

    $per_action[$path]['lines_removed'] = $action['git_specific']['lines_removed'];
    $total_lines_removed += $action['git_specific']['lines_removed'];
  }

  return array(
    'lines_added' => $total_lines_added,
    'lines_removed' => $total_lines_removed,
    'action_count' => count($per_action),
    'per_action_statistics' => $per_action,
  );
}
*/
/**
 * Implementation of [versioncontrol_backend]_get_directory_item():
 * Retrieve the item of the deepest-level directory in the repository that is
 * common to all the changed/branched/tagged items in a commit, branch or
 * tag operation. In other words, this function gets you the item
 * for $operation['directory'].
 *
 * @param $operation
 *   The commit, branch or tag operation whose deepest-level
 *   changed/branched/tagged directory should be retrieved.
 *
 * @return
 *   The requested directory item. Item values are structured arrays and
 *   consist of elements with the following keys:
 *
 *   - 'type': Specifies the item type, which in this case can only be
 *        VERSIONCONTROL_ITEM_DIRECTORY.
 *   - 'path': The path of the directory, which will be the same
 *        as $operation['directory'].
 *   - 'revision': The (file-level) revision when the item was last changed.
 *        If there is no such revision (which may be the case for
 *        directory items) then the 'revision' element is an empty string.
 *   - '[xxx]_specific': May be set by the backend to remember additional
 *        item info. ("[xxx]" is the unique string identifier
 *        of the respective version control system.)
 */
/*
function versioncontrol_git_get_directory_item($operation) {
  $item = array(
    'type' => VERSIONCONTROL_ITEM_DIRECTORY,
    'path' => $operation['directory'],
    'revision' => '',
    'git_specific' => array(
      'selected_op' => $operation,
    ),
  );

  if (isset($operation['git_specific']['branch_ids'])) { // It's a commit or branch.
    $item['git_specific']['selected_branch_ids'] = $operation['git_specific']['branch_ids'];
  }
  return $item;
}
*/
/**
 * Implementation of [versioncontrol_backend]_get_commit_branches():
 * Retrieve the branches that have been affected by the given commit.
 *
 * @return
 *   An array of strings that identify a branch in the respective repository,
 *   or an empty array if no branches were affected at all.
 */
/*
function versioncontrol_git_get_commit_branches($commit) {
  if (!isset($commit['git_specific']['branch_ids'])) {
    return array();
  }

  // Get branches.
  $branches = array();
  foreach ($commit['git_specific']['branch_ids'] as $branch_id) {
    $branch = versioncontrol_get_branch($branch_id);
    $branches[] = $branch['branch_name'];
  }
  return $branches;
}
*/
/**
 * Retrieve the set of items that were affected by a branch operation.
 *
 * @param $branch
 *   The branch operation whose items should be retrieved. This is an array
 *   like the one returned by versioncontrol_get_branch_operation().
 *
 * @return
 *   An array of all items that were affected by the branching operation.
 *   An empty result array means that the whole repository has been branched.
 *   Item values are structured arrays and consist of elements
 *   with the following keys:
 *
 *   - 'type': Specifies the item type, which is either
 *        VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   - 'path': The path of the item at the specific revision.
 *   - 'revision': The (file-level) revision when the item was changed.
 *        If there is no such revision (which may be the case for
 *        directory items) then the 'revision' element is an empty string.
 *   - 'source branch': Optional, may be set by the backend if the
 *        source branch (the one that this one branched off) can be retrieved.
 *        If given, this is a string with the original branch name.
 *   - '[xxx]_specific': May be set by the backend to remember additional
 *        item info. ("[xxx]" is the unique string identifier of the respective
 *        version control system.)
 */
/*
function versioncontrol_git_get_branched_items($branch) {
  return array(); // Branches affect whole repository.
}*/

/**
 * Retrieve the set of items that were affected by a tag operation.
 *
 * @param $tag
 *   The tag operation whose items should be retrieved. This is an array
 *   like the one returned by versioncontrol_get_tag_operation().
 *
 * @return
 *   An array of all items that were affected by the tagging operation.
 *   An empty result array means that the whole repository has been tagged.
 *   Item values are structured arrays and consist of elements
 *   with the following keys:
 *
 *   - 'type': Specifies the item type, which is either
 *        VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   - 'path': The path of the item at the specific revision.
 *   - 'revision': The (file-level) revision when the item was changed.
 *        If there is no such revision (which may be the case for
 *        directory items) then the 'revision' element is an empty string.
 *   - 'source branch': Optional, may be set by the backend if the
 *        source branch (the one that this tag comes from) can be retrieved.
 *        If given, this is a string with the original branch name.
 *   - '[xxx]_specific': May be set by the backend to remember additional
 *        item info. ("[xxx]" is the unique string identifier of the respective
 *        version control system.)
 */
/*
function versioncontrol_git_get_tagged_items($tag) {
  return array();
}*/

/**
 * Implementation of [versioncontrol_backend]_get_current_item_branch():
 * Retrieve the current branch that this item is in. If this item was part of
 * the result of versioncontrol_get_commit_actions(), this will probably be
 * the branch that this item was committed to. The main branch ('HEAD' for Git)
 * is also a valid branch and should be expected as return value.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose current branch should be retrieved.
 *
 * @return
 *   A string containing the current item branch, or NULL if no branch
 *   is known or applicable.
 */
/*
function versioncontrol_git_get_current_item_branch($repository, $item) {
  if (!isset($item['git_specific']['selected_branch_id'])) {
    return NULL;
  }

  $branch = versioncontrol_get_branch($item['git_specific']['selected_branch_id']);
  if (!isset($branch)) {
    return NULL;
  }
  return $branch['branch_name'];
}*/

/**
 * Implementation of [versioncontrol_backend]_get_current_item_tag():
 * Retrieve the current tag of this item.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose current branch should be retrieved.
 *
 * @return
 *   A tag operation array like the return value
 *   of versioncontrol_get_tag_operation(), or NULL if no tag
 *   is known or applicable.
 */
/*
function versioncontrol_git_get_current_item_tag($repository, $item) {
  if ($item['git_specific']['selected_op']['type'] != VERSIONCONTROL_OPERATION_TAG) {
    return NULL;
  }
  return $item['git_specific']['selected_op'];
}
*/
/**
 * Implementation of [vcs_backend]_get_parent_item():
 * Retrieve the parent (directory) item of a given item.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose parent should be retrieved.
 * @param $parent_path
 *   NULL if the direct parent of the given item should be retrieved,
 *   or a parent path that is further up the directory tree.
 *
 * @return
 *   The parent directory item at the same revision as the given item.
 *   If $parent_path is not set and the item is already the topmost one
 *   in the repository, the item is returned as is. It also stays the same
 *   if $parent_path is given and the same as the path of the given item.
 *   If the given directory path does not correspond to a parent item,
 *   NULL is returned.
 */
/*
function versioncontrol_git_get_parent_item($repository, $item, $parent_path = NULL) {
  if (!isset($parent_path)) {
    $item['path'] = dirname($item['path']);
    return $item;
  }
  else if (strpos($item['path'] .'/', $parent_path .'/') !== FALSE) {
    $item['path'] = $parent_path;
    return $item;
  }
  return NULL;
}*/

/**
 * Menu callback for 'admin/project/versioncontrol-repositories/update/git'
 * (expecting a $repo_id as one more path argument):
 * Retrieve/validate the specified repository, fetch new commits, tags
 * and branches by invoking the git executable, output messages and
 * redirect back to the repository page.
 */

function versioncontrol_git_update_repository_callback($repo_id) {
  if (is_numeric($repo_id)) {
    $repository = versioncontrol_get_repository($repo_id);

    if (isset($repository)) {
      $update_method = $repository['git_specific']['update_method'];
    }
  }
  if (isset($update_method) && $update_method == VERSIONCONTROL_GIT_UPDATE_CRON) {
    // Set timeout limit to 3600 seconds as it can take a long time
    // to process the log initially.
    if (!ini_get('safe_mode')) {
      set_time_limit(3600);
    }
    if (_versioncontrol_git_update_repository($repository)) {
      drupal_set_message(t('Fetched new log entries.'));
    }
    else
    {
      drupal_set_message(t('Error while fetching new log entries.'), 'error');
    }
  }
  else { // $repo_id is not a number or doesn't correlate to any repository.
    drupal_set_message(t('No such repository, did not fetch anything.'));
  }
  drupal_goto('admin/project/versioncontrol-repositories');
}

/**
 * Actually update the repository by fetching commits and other stuff
 * directly from the repository, invoking the git executable.
 *
 * @return
 *   TRUE if the logs were updated, or FALSE if fetching and updating the logs
 *   failed for whatever reason.
 */

function _versioncontrol_git_update_repository(&$repository) {
  include_once(drupal_get_path('module', 'versioncontrol_git') .'/versioncontrol_git.log.inc');
  return _versioncontrol_git_log_update_repository($repository);
}

/**
 * Implementation of [versioncontrol_backend]_commit():
 * Manage (insert or delete) additional commit data in the database.
 *
 * @param $op
 *   Either 'insert' when the commit is in the process of being created,
 *   or 'delete' if it will be deleted after this function has been called.
 * @param $commit
 *   A single commit array, like the ones returned
 *   by versioncontrol_get_commits().
 * @param $commit_actions
 *   A structured array containing the exact details of what happened to
 *   each item in this commit. The structure of this array is the same as
 *   the return value of versioncontrol_get_commit_actions().
 */
/*
function versioncontrol_git_commit($op, $commit, $commit_actions) {
  switch ($op) {
    case 'insert':
      // Insert branches.
      foreach ($commit['git_specific']['branch_ids'] as $branch) {
         db_query("INSERT INTO {versioncontrol_git_commit_branches} (vc_op_id, branch_id) VALUES (%d, %d)",
           $commit['vc_op_id'], $branch);
      }

      foreach ($commit_actions as $path => $action) {
        $revision = '';

        // If available, get item type and revision from the contained items.
        if (isset($action['current item'])) {
          $type = $action['current item']['type'];
          $revision = $action['current item']['revision'];
        }
        else { // no current item -> file has been deleted
          $type = VERSIONCONTROL_ITEM_FILE_DELETED;
          $revision = $action['git_specific']['revision'];
        }

        $item_revision_id = db_last_insert_id('{versioncontrol_git_item_revisions}_item_revision_id');
        db_query(
          "INSERT INTO {versioncontrol_git_item_revisions}
           (item_revision_id, vc_op_id, type, path,
            action, lines_added, lines_removed)
           VALUES (%d, %d, %d, '%s', %d, %d, %d)",
          $item_revision_id, $commit['vc_op_id'], $type, $path,
          $action['action'], $action['git_specific']['lines_added'],
          $action['git_specific']['lines_removed']
        );

        db_query("INSERT INTO {versioncontrol_git_item_source_revisions}
                  (item_revision_id, source_item_revision_id)
                  VALUES (%d, %d)",
          $item_revision_id,
          _versioncontrol_git_get_item_revision_id($action['source items'][0]['path'], $action['source items'][0]['revision']));
      }
      break;

    case 'delete':
      $result = db_query('SELECT ir.item_revision_id, c.revision
                          FROM {versioncontrol_git_item_revisions} ir
                           INNER JOIN {versioncontrol_commits} c
                            ON ir.vc_op_id = c.vc_op_id
                          WHERE ir.vc_op_id = %d', $commit['vc_op_id']);

      while ($revision = db_fetch_object($result)) {
        db_query('DELETE FROM {versioncontrol_git_item_tags}
                  WHERE item_revision_id = %d',
                  $revision->item_revision_id);
        db_query('DELETE FROM {versioncontrol_git_item_source_revisions}
                  WHERE item_revision_id = %d OR source_item_revision_id = %d',
                  $revision->item_revision_id, $revision->item_revision_id);
        db_query("DELETE FROM {versioncontrol_git_latest_commits}
                  WHERE revision = '%s'",
                  $revision->revision);
      }
      db_query('DELETE FROM {versioncontrol_git_item_revisions}
                WHERE vc_op_id = %d', $commit['vc_op_id']);
      db_query('DELETE FROM {versioncontrol_git_commit_branches}
                WHERE vc_op_id = %d', $commit['vc_op_id']);
      break;
  }
}
*/
/**
 * Get the item_revision_id for the revision with the specified path
 * and revision hash.
 */
/*
function _versioncontrol_git_get_item_revision_id($path, $revision) {
  $result = db_result(db_query("SELECT ir.item_revision_id
                                FROM {versioncontrol_git_item_revisions} ir
                                 INNER JOIN {versioncontrol_commits} c
                                  ON ir.vc_op_id = c.vc_op_id
                                WHERE ir.path = '%s' AND c.revision = '%s'",
                                $path, $revision));
  return ($result !== FALSE ? $result : -1);
}*/

/**
 * Implementation of [versioncontrol_backend]_tag_operation():
 * Manage (insert or delete) additional tag data in the database.
 *
 * @param $op
 *   'insert' when the tag operation has just been recorded and inserted
 *   into the database, or 'delete' if it will be deleted right after this hook
 *   has been called.
 *
 * @param $tag
 *   A structured array that consists of the following elements:
 *
 *   - 'vc_op_id': The Drupal-specific operation identifier (a simple integer)
 *        which is unique among all operations (commits, branch ops, tag ops)
 *        in all repositories.
 *   - 'type': The type of the operation, which is
 *        VERSIONCONTROL_OPERATION_TAG for tags.
 *   - 'tag_name': The name of the tag (a string like 'DRUPAL-6--1-1').
 *   - 'action': Specifies what happened to the tag. This is
 *        VERSIONCONTROL_ACTION_ADDED if the tag was created,
 *        VERSIONCONTROL_ACTION_MOVED if was renamed,
 *        or VERSIONCONTROL_ACTION_DELETED if was deleted.
 *   - 'date': The time when the tagging was done, given as Unix timestamp.
 *   - 'uid': The Drupal user id of the committer, or 0 if no Drupal user
 *        could be associated to the committer.
 *   - 'username': The system specific VCS username of the committer.
 *   - 'repository': The repository where the tagging occurred,
 *        given as a structured array, like the return value
 *        of versioncontrol_get_repository().
 *   - 'directory': The deepest-level directory in the repository that is
 *        common to all the tagged items, e.g. '/src' if the files
 *        '/src/subdir/code.php' and '/src/README.txt' were tagged.
 *   - 'message': The tag message that the user has given. If the version
 *        control system doesn't support tag messages, this is an empty string.
 *   - '[xxx]_specific': An array of VCS specific additional tag operation info.
 *        How this array looks like is defined by the corresponding
 *        backend module (versioncontrol_[xxx]).
 *
 * @param $tagged_items
 *   An array of all items that were affected by the tagging operation.
 *   An empty result array means that the whole repository has been tagged.
 *   Item values are structured arrays and consist of elements
 *   with the following keys:
 *
 *   - 'type': Specifies the item type, which is either
 *        VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY.
 *   - 'path': The path of the item at the specific revision.
 *   - 'revision': The (file-level) revision when the item was changed.
 *        If there is no such revision (which may be the case for
 *        directory items) then the 'revision' element is an empty string.
 *   - 'source branch': Optional, may be set by the backend if the
 *        source branch (the one that this tag comes from) can be retrieved.
 *        If given, this is a string with the original branch name.
 *   - '[xxx]_specific': May be set by the backend to remember additional
 *        item info. ("[xxx]" is the unique string identifier of the respective
 *        version control system.)
 *
 * @ingroup Tags
 * @ingroup Commit notification
 * @ingroup Database change notification
 */
/*
function versioncontrol_git_tag_operation($op, $tag, $tagged_items) {
  switch ($op) {
    case 'insert':
      db_query(
        "INSERT INTO {versioncontrol_git_tag_operations}
         (vc_op_id, revision)
         VALUES (%d, '%s')",
         $tag['vc_op_id'], $tag['git_specific']['revision']
    );
    break;

    case 'delete':
      db_query('DELETE FROM {versioncontrol_git_tag_operations}
        WHERE vc_op_id = %d',
      $tag['vc_op_id']);
    break;
  }
}*/

/**
 * Implementation of [versioncontrol_backend]_repository():
 * Manage (insert, update or delete) additional FakeVCS repository data
 * in the database.
 *
 * This function is optional for backend modules to implement. If you don't
 * need custom repository data (or you let the Version Control API manage it),
 * just don't implement it.
 *
 * @param $op
 *   Either 'insert' when the repository has just been created, or 'update'
 *   when repository name, root, URL backend or module specific data change,
 *   or 'delete' if it will be deleted after this function has been called.
 *
 * @param $repository
 *   The repository array containing the repository. It's a single
 *   repository array like the one returned by versioncontrol_get_repository(),
 *   so it consists of the following elements:
 *
 *   - 'repo_id': The unique repository id.
 *   - 'name': The user-visible name of the repository.
 *   - 'vcs': The unique string identifier of the version control system
 *        that powers this repository.
 *   - 'root': The root directory of the repository. In most cases,
 *        this will be a local directory (e.g. '/var/repos/drupal'),
 *        but it may also be some specialized string for remote repository
 *        access. How this string may look like depends on the backend.
 *   - 'authorization_method': The string identifier of the repository's
 *        authorization method, that is, how users may register accounts
 *        in this repository. Modules can provide their own methods
 *        by implementing hook_versioncontrol_authorization_methods().
 *   - 'url_backend': The prefix (excluding the trailing underscore)
 *        for URL backend retrieval functions.
 *   - '[xxx]_specific': An array of VCS specific additional repository
 *        information. How this array looks like is defined by the
 *        corresponding backend module (versioncontrol_[xxx]).
 */
/*
function versioncontrol_git_repository($op, $repository) {
  if ($op == 'update') {
    variable_set('versioncontrol_git_log_use_file', $repository['use_file']);
    unset($repository['use_file']);
  }
}*/

/**
 * Get the current revision (commit id) of file under version control,
 * given the repository id and path.
 * 
 * @return string Current revision (commit id).
 */
/*
function versioncontrol_git_get_current_revision($repo_id, $path) {
  $result = db_fetch_object(db_query(
    "SELECT ir.action, c.revision
     FROM {versioncontrol_git_item_revisions} ir
      INNER JOIN {versioncontrol_operations} op
       ON ir.vc_op_id = op.vc_op_id
      INNER JOIN {versioncontrol_commits} c
       ON ir.vc_op_id = c.vc_op_id
     WHERE op.repo_id = %d AND ir.path = '%s'
     ORDER BY ir.item_revision_id DESC
     LIMIT 1",
    $repo_id, $path
  ));
  if ($result !== FALSE && $result->action != VERSIONCONTROL_ACTION_DELETED) {
    return $result->revision;
  }
  return NULL;
}*/

/**
 * Get the source items of the specified item revision.
 * 
 * @return array Source items.
 */
/*
function versioncontrol_git_get_source_items($item_revision_id) {
  $result = db_query(
    "SELECT source_item_revision_id
     FROM {versioncontrol_git_item_source_revisions}
     WHERE item_revision_id = '%s'",
    $item_revision_id
  );

  $source_revisions = array();
  while ($source_revision = db_fetch_object($result)) {
    $source_revisions[] = $source_revision->source_item_revision_id;
  }
  return $source_revisions;
}*/

/*
function versioncontrol_git_get_item_revision($item_revision_id) {
  return db_result(db_query(
    'SELECT revision
     FROM {versioncontrol_commits} c
      INNER JOIN {versioncontrol_git_item_revisions} ir
       ON c.vc_op_id = ir.vc_op_id
     WHERE ir.item_revision_id = %d',
     $item_revision_id
  ));
}
*/
